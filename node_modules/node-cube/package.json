{
  "author": {
    "name": "fish",
    "email": "zhengxinlin@gmail.com",
    "url": "https://github.com/fishbar"
  },
  "name": "node-cube",
  "description": "a new way to write js in browser",
  "version": "0.0.16",
  "homepage": "https://github.com/fishbar/cube",
  "repository": {
    "type": "git",
    "url": "git://github.com/fishbar/cube.git"
  },
  "main": "index.js",
  "bin": {
    "cube": "./bin/cube"
  },
  "scripts": {
    "test": "mocha -r jscoverage --coverage 70,80,95 -R spec test"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "commander": "2.2.0",
    "connect": "2.14.4",
    "uglify-js": "2.4.13",
    "clean-css": "2.1.8",
    "less": "1.7.0",
    "xfs": "0.1.10",
    "stylus": "0.46.3",
    "coffee-script": "1.7.1",
    "jade": "1.3.1",
    "ejs": "1.0.0",
    "debug": "1.0.3"
  },
  "devDependencies": {
    "jscoverage": "0.5.3",
    "mocha": "1.20.1",
    "expect.js": "0.3.1",
    "supertest": "0.13.0",
    "jsdom": "0.11.1"
  },
  "optionalDependencies": {},
  "readme": "Cube\r\n=================\r\n\r\n![logo](https://raw.github.com/fishbar/cube/master/logo.png)\r\n\r\n像node.js一样编写浏览器端代码，无需争端AMD、还是CMD，只是build方式的不同，重要的是书写方便、简洁。\r\n\r\nCube提供一个http服务的能力，源码上支持js, coffee, less, styl, ejs, jade。\r\nCube会将这些语言，转换为服务于web的js 和 css\r\n\r\n## install\r\n\r\n  npm install -g node-cube\r\n\r\n## init\r\n\r\n  每一个web应用都有一包静态资源\r\n  每一个web应用的静态资源，都应该被设计成可自由部署 (static.server/path, 虽然很多时候静态资源都在同域下)\r\n  每一个web应用都会包含这么一个目录叫静态资源, 比如:\r\n\r\n```sh\r\n  webapp -|\r\n          | - wwwroot | << 静态资源目录\r\n                      | - js\r\n                      | - css\r\n                      | - imgs\r\n```\r\n\r\n  cube的初始化就从这个wwwroot开始，进入wwwroot目录，cube内建静态资源服务，启动服务:\r\n\r\n```sh\r\n  cd static_dir\r\n  # 初始化工程\r\n  cube init  // --jade 启用jade, --ejs 启用ejs\r\n  # 启动静态服务\r\n  cube start\r\n```\r\n\r\n  根据命令行提示的地址访问, ok，你的前端资源可以像node.js一样编写了。\r\n\r\n  在设计前端框架的时候，通常都会考虑到这点：前端资源需要可以被方便的部署到CDN等资源（动静态资源分离）\r\n  cube的运行模式就是遵循这一设计思路的\r\n\r\n## 集成到项目的connect中\r\n\r\n  假如你的工程已经是connect工程，或者express工程，那么可以很方便的将cube集成到工程中\r\n  cube可以返回一个middleware方法 `middleware(req, res, next)`\r\n\r\n```js\r\n  var Cube = require('node-cube');\r\n  var middleware = Cube.init({\r\n    root: '/wwwroot',  // static resource path, like wwwwroot below\r\n    middleware: true  // run as a service, not return a middleware\r\n  });\r\n  app.use('/static', middleware);\r\n```\r\n  ok, 访问你的调试环境  `http://localhost:port/static/xxx`, 静态资源+模块化支持\r\n\r\n\r\n## 编写一个模块\r\n\r\n```js\r\n// header.js\r\nvar cookie = require('cookie');\r\nfunction  init() {\r\n  var nick = cookie.get('nick');\r\n  if (!nick) {\r\n    nick = 'guest';\r\n  }\r\n  $('node-nick').text(nick);\r\n}\r\n\r\ninit();\r\n// 异步加载脚本\r\nasync('./tset.tpl', function(render) {\r\n  render({appName: \"cube\"});\r\n});\r\n// 异步加载css\r\nasync('../css/module.css', nameSpace); // namespace: prefix for css selector\r\n```\r\nok，一个很简单的一个模块，设置头部用户登录昵称\r\n\r\n模块加载是支持像node一样寻址node_modules目录的，在wwwroot目录下安装模块，可以被直接require使用， 所以把你的代码写好了，发布到npm公用吧！\r\n\r\n引用现有的包， 你只需要 (a)编写好package依赖 (b) `npm install` (c) 像node一样引用这些模块\r\n\r\n## 部署浏览器端\r\n\r\n```html\r\n<script src='/cube.js'></script>\r\n<script>\r\n  Cube.init({\r\n    charset: 'utf-8',\r\n    base: '/project/static/',  // virtual path, base can be cdn server: http://tbcdn.cn/edp/\r\n    debug: true,               // online module ,you should turn off this switch\r\n    enableCss: true,           // enable dynamic loading css resource\r\n    version: 12345,            // the code version, used for flushing client side script\r\n    timeout: 2000              // loading script timeout setup\r\n  });\r\n  Cube.use(appConfig.main, function (App) {\r\n    console.log(App.run(appConfig));\r\n  });\r\n</script>\r\n```\r\n\r\n## 优化加载\r\n\r\n  模块化之后带来的一个问题，就是文件非常零碎，有时候甚至影响到了执行性能。\r\n  这个时候可以通过 `@merge` 这个标记来优化文件\r\n\r\n```js\r\n/**\r\n * file description\r\n * @merge\r\n */\r\nvar a = require('a');\r\nvar b = require('b');\r\nvar c = require('c');\r\n```\r\n  通过标记`@merge`, 服务器会将`a`,`b`,`c`三个模块合并到当前模块的文件中，一起输出。\r\n  通过这个方法，可以将整个app中常用的一些模块打包成一个文件\r\n\r\n## 打包发布\r\n\r\n进入生产环境之前，模块都会被预编译、压缩成一个个小文件，然后发布到线上(cdn服务器、云存储 或 其他)\r\n\r\n```sh\r\ncube build resource_path\r\n```\r\n\r\n在静态资源目录下，编写 `.cubeignore`来排除不需要被处理的文件，格式和.gitignore一样",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fishbar/cube/issues"
  },
  "_id": "node-cube@0.0.16",
  "dist": {
    "shasum": "4133123618db7a724f4493e869c2d1e0aeecf01c"
  },
  "_from": "node-cube@*",
  "_resolved": "https://registry.npmjs.org/node-cube/-/node-cube-0.0.16.tgz"
}
